面试题31. 栈的压入、弹出序列
难度中等27
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。假设压入栈的所有数字均不相等。例如，序列 {1,2,3,4,5} 是某栈的压栈序列，序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。
?
示例 1：
输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]输出：true解释：我们可以按以下顺序执行：push(1), push(2), push(3), push(4), pop() -> 4,push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1
示例 2：
输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]输出：false解释：1 不能在 2 之前弹出。

来自 <https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/> 
class?Solution?{
????public?boolean?validateStackSequences(int[]?pushed,?int[]?popped)?{
????????Stack<Integer>?temp?=?new?Stack<>();
????????int?i?=?0;
????????for(int?num?:?pushed)
????????{
????????????temp.push(num);//入栈
????????????//模拟出栈
????????????while(!temp.isEmpty()?&&?temp.peek()?==?popped[i])
????????????{
????????????????temp.pop();
????????????????i?++;
????????????}
????????}
????????return?temp.isEmpty();
????}
}




Java Stack中add与push，peek与pop

?
add & push

共同点：

add，push都可以向stack中添加元素。

不同点：

add是继承自Vector的方法，且返回值类型是boolean。

push是Stack自身的方法，返回值类型是参数类类型。

具体的看源码：

public synchronized boolean add(E e) {
        modCount++;
        ensureCapacityHelper(elementCount + 1);
        elementData[elementCount++] = e;
        return true;
    }
public E push(E item) {
        addElement(item);
 
        return item;
    }
peek & pop

共同点：

peek，pop都是返回栈顶元素。

不同点：

peek()函数返回栈顶的元素，但不弹出该栈顶元素。
pop()函数返回栈顶的元素，并且将该栈顶元素出栈。
――――――――――――――――
版权声明：本文为CSDN博主「notZheng」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_41126303/java/article/details/83013444


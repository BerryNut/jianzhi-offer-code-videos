面试题07. 重建二叉树
难度中等76
输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。
?
例如，给出
前序遍历 preorder =?[3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7]
返回如下的二叉树：
    3   / \  9  20    /  \   15   7

来自 <https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/> 

/**
?*?Definition?for?a?binary?tree?node.
?*?public?class?TreeNode?{
?*?????int?val;
?*?????TreeNode?left;
?*?????TreeNode?right;
?*?????TreeNode(int?x)?{?val?=?x;?}
?*?}
?*/
class?Solution?{
????//树??递归
????int?preindex?=?0;
????int?inindex?=?0;
????public?TreeNode?buildTree(int[]?preorder,?int[]?inorder)?{
????????return?dfs(preorder,?inorder,?null);
????}
????private?TreeNode?dfs(int[]?preorder,?int[]?inorder,?TreeNode?finish)
????{
????????if(preindex?==?preorder.length?||?(finish?!=?null?&&??inorder[inindex]?==?finish.val))
????????????return?null;
????????//遍历过程?
????????//前序?跟左右
????????TreeNode?root?=?new?TreeNode(preorder[preindex?++]);
????????//左子树
????????root.left?=?dfs(preorder,?inorder,?root);
????????inindex?++;
????????//右子树
????????root.right?=?dfs(preorder,?inorder,?finish);
????????return?root;
????}
}

